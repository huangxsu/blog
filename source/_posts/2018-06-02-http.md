---
title:  HTTP协议（下）
date: 2018-06-02 11:10:00
tags:
- HTTP
- SSL/TLS
- HTTPS
- HTTP/2
- WebSocket
---

重要的 HTTP 协议，很重要。《图解 HTTP》读书笔记，作者：上野 宣，译者：于均良。**（未完待续……）**

<!--more-->

# 与 HTTP 协作的 Web 服务器

## 多域名虚拟主机

{% asset_img virtual-host.png 虚拟主机 %}

HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。客户端使用 HTTP 协议访问服务器时，经常采用类似 www.abc.com 这样的主机域名。域名通过 DNS 服务映射到 IP 地址之后访问目标网站。在相同的 IP 地址下，由于虚拟主机可以寄存多个不同的主机域名，因此发送 HTTP 请求时，必须在 Host 首部内指定主机域名的 URI。

## 通信数据转发程序：代理、网关、隧道

1.  代理 是一种有转发功能的应用程序，扮演了位于服务器和客户端“中间人”的角色，使用代理服务器的理由有：利用缓存技术减少网络带宽流量；对特定网站的访问控制；获取访问日志。

缓存代理：代理转发响应时，缓存代理会预先将资源的副本保存在代理服务器上。当再次接收到相同资源请求是，就可以不从源服务器那里获取，将之前缓存的资源作为响应返回。

透明代理：转发请求或响应时，不对报文做任何加工被称为透明代理。

2.  网关 是转发其他服务器通信数据的服务器。

3.  隧道 在相隔甚远的客户端和服务器之间进行中转，并保持双方通信链接的应用程序。目的是确保客户端和服务器进行安全的通信。

## 缓存

缓存是指代理服务器或客户端本地磁盘内保存资源副本。利用缓存可减少对源服务器的访问，节省通信流量和通信时间。

1.  缓存服务器 是代理服务器的一种
2.  客户端缓存（浏览器）
3.  有效期 缓存失效， 会再次请求新资源。

# 确保 Web 安全的 HTTPS

## HTTP 的缺点

1、 通信使用明文（不加密），内容可能会被窃听

加密处理防止被窃听：

1.  通信加密： HTTP 协议没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。与 SSL 组合使用的 HTTP 被称为 HTTPS。

2.  内容加密： 为了做到有效的内容加密，前提是要求客户端和服务器同事具备加密和解密机制。

2、 不验证通信方的身份，因此有可能能遭遇伪装

任何人都可以发起请求：即使是无意义的请求也会照单全收，无法阻止海量请求下的 Dos 攻击（Denial of Service， 拒绝服务攻击）。

查明对手的证书：

虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL 则可以。SSL 提供了一种证书方法可用于确定对方身份。

证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。

3、 无法证明报文的完整性，所以有可能已遭篡改

## HTTP + 加密 + 认证 + 完整性保护 = HTTPS

1、 HTTPS 是身批 SSL 外壳的 HTTP

通常，HTTP 直接和 TCP 通信。当使用 SSL 时，先和 SSL 通信，再由 SSL 和 TCP 通信。SSL 独立于 HTTP 协议，不仅 HTTP 协议，其他运行在应用层的 SMTP 和 Telent 等协议均可配合 SSL 协议使用。

{% asset_img HTTPS.png HTTPS %}

2、 对称密钥和非对称密钥加密

1.  对称密钥加密（共享密钥）技术 加密和解密使用的是同一个密钥
2.  非对称加密（公开密钥）技术 两个密钥，私有密钥和公开密钥。发送密文一方使用对方的公开密钥加密，对方收到密文后，使用自己的私有密钥解密。

3、 HTTPS 采用混合加密机制

非对称密钥安全性高，但是速度比对称秘钥慢。所以，在交换密钥环节使用公开密钥方法，之后建立通信交换报文阶段使用共享密钥，既保证安全又提升效率。

4、 证明公开密钥正确性的证书

为了确保公开密钥在传输图中没有被掉包，可以使用数字认证机构（CA, Certificate Authority）颁发的公开密钥证书。服务器将证书发送给客户端，客户端使用 CA 的公开密钥校验证书。浏览器开发商会事先在内部植入常用认证机关的公开密钥，保证认证机关的密钥是安全可靠的。

5、 HTTPS 的安全通信机制

{% asset_img SSL.png SSL %}

1.  客户端向服务器发出加密通信请求（ClientHello），并向服务器提供：支持的协议版本；一个随机数（Client random）；支持加密的方法；支持压缩的方法。
2.  服务器回应（ServerHello）：确认使用的加密通信协议版本；一个随机数（Server random）；确认使用的加密方法；服务器证书。
3.  客户端收到服务器回应后，首先验证证书，通过后取出公钥，向服务器发送：一个用公钥加密的随机数（Premaster secret）；编码改变通知（表示随后的信息将用双方商定的加密方式和密钥发送）；客户端握手结束（这一项同时也是前面发送的所有内容的 hash 值，供服务器校验）。
4.  服务器的最后回应，服务器使用私钥获取 Premaster secret 之后，计算生产本次会话所有的“会话密钥（对称秘钥）”，向客户端发送：编码改变通知；服务器握手结束通知。

接下来，客户端和服务器使用“会话秘钥”进入加密通信。

{% asset_img SSL-Handshake.png SSL Handshake %}

6、 SSL 和 TLS

SSL 技术最初是由浏览器开发商网景通信公司率先倡导的， 开发过 SSL3.0 之前的版本。 目前主导权已转移到 IETF（Internet Engineering Task Force， Internet 工程任务组） 的手中。

IETF 以 SSL3.0 为基准， 后又制定了 TLS1.0、 TLS1.1 和 TLS1.2。 TSL 是以 SSL 为原型开发的协议， 有时会统一称该协议为 SSL。 当前主流的版本是 SSL3.0 和 TLS1.0

7、 SSL 速度慢吗

1.  通信慢。和 HTTP 相比，出去 TCP 连接、发送 HTTP 请求、响应之外，还要进行 SSL 通信
2.  必须进行加密解密处理。比起 HTTP 会更多的消耗服务器和客户端的硬件资源。

# 基于 HTTP 的功能追加协议

## HTTP 的瓶颈

1.  请求只能从客户端开始，客户端不可以接收出响应以外的指令
2.  请求/响应首部未经压缩就发送。首部信息越多延迟越大
3.  每次互相发送相同的首部造成浪费

## 消除 HTTP 瓶颈的 SPDY

在介绍 SPDY 之前，先来了解一下 Ajax 和 Comet 对 HTTP 瓶颈的优化。

1.  Ajax 的核心技术是 XMLHttpRequest 的 API，通过 JS 脚本调用和服务器进行 HTTP 通信，从已加载完毕的 Web 页面上发起请求，实现局部更新，响应传输的数据量会因此减少。
2.  Comet 技术通过延迟应答，模拟实现服务器端想客户端推送（Server Push）的功能。通常，服务器端接收到请求，在处理完毕后会立即返回响应，但是为了实现推动功能，Comet 会先将响应置于挂起状态，当服务器有内容更新是，在返回改响应。
3.  SPDY 在 TCP/IP 的应用层与传输层自己新加一层会话层，同时基于安全考虑，SPDY 规定通信中使用 SSL

{% asset_img spdy.png 会话层 %}

使用 SPDY 后，HTTP 协议会获得以下功能：

1.  多路复用流：一个 TCP 连接，可以无限制处理多个 HTTP 请求
2.  赋予请求优先级
3.  压缩 HTTP 首部
4.  推送功能，支持服务端主动向客户端推送数据
5.  服务器提示功能：服务器可以主动提示客户端请求所需的资源

## 期盼已久的 HTTP/2

2015 年，HTTP/2 发布，它不叫 HTTP/2.0，因为标准委员会不打算发布子版本了，下一个新版本将是 HTTP/3。下面介绍 HTTP/2 的新特性：

1.  二进制协议：HTTP/1.1 版的头信息是文本，数据体可以是文本也可以是二进制。HTTP/2 头信息和数据体都是二进制，并且统称为“帧”：头信息帧和数据帧

{% asset_img binary_framing_layer01.svg 500 二进制分帧层%}

2.  多工： HTTP/2 复用 TCP 连接，在一个连接里，客户端和服务端可以同时发送多个请求或响应，而且不用按照顺序一一对应，避免了“对头堵塞”，这样双向、实时的通信叫多工（Multiplexing）。每个来源一个连接，HTTP/2 不再依赖多个 TCP 并行。

{% asset_img binary_multiplexing01.svg 500 多工%}

3.  数据流：HTTP/2 的数据包不是按顺序发送的，同一个连接里连续的数据包可能属于不同的响应。因此必须对数据包做标记，指出它属于哪一个回应。HTTP/2 将每个请求或响应的说要数据包称为一个**数据流**，每个数据流有一个独一无二的编码，数据包发送的时候必须标记数据流 ID。另外还规定，客户端发出的数据流 ID 为奇数，服务端为偶数。数据流发送到一半时，客户端和服务端都可以发送 RST_STREAM 帧，取消这个数据流。HTTP/1.1 取消数据流的唯一方式是关闭 TCP 连接，HTTP/2 可以取消某次请求，同时保证 TCP 连接还打开着。客户端可以指定数据流的优先级。

4.  头信息压缩：HTTP 协议不记录状态，每次请求都必须带上所有信心，其中很多字段都是重复的。HTTP/2 对这一点做了优化，一方面头信息使用 gzip 或 compress 压缩后再发送，另一方面，客户端和服务端同时维护一张头信息表，所以字段都会存入这个表，生成一个索引号，以后就不发生同样的字段了，已发送索引号。

{% asset_img header_compression01.svg 500 头信息压缩 %}

5.  服务器推送：HTTP/2 允许服务器未经请求，主动向客户端发送资源。比如，客户端请求一个网页，包含很多静态资源。正常情况下，客户端必须收到网页后，解析 HTML 源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

{% asset_img push01.svg 500 服务器推送 %}

注：在 HTTP/2 中，请求和响应标头字段的定义保持不变，仅有一些微小的差异：所有标头字段名称均为小写，请求行现在拆分成各个 :method、:scheme、:authority 和 :path 伪标头字段。

## 使用浏览器进行全双工通信的 WebSocket

WebSocket，Web 浏览器与 Web 服务器之间全双工通信标准。其特点包括：

1.  支持由服务器向客户端推送数据的功能
2.  建立在 TCP 协议之上，服务器端的实现比较容易
3.  与 HTTP 协议有良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器
4.  数据格式轻量，性能开销小，通信高效
5.  可以发送文本或二进制数据
6.  没有同源限制，客户端可以与任意服务器通信
7.  协议标识是`ws`，如果加密则为`wss`

{% asset_img websocket.jpg WebSocket 协议 %}

为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次握手的步骤：

1.  握手——请求

为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，以达到握手的目的。Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值。

2.  握手——响应

对于之前的请求，返回状态码 101 Switching Protocols 的响应，Sec-WebSocket-Accept 的字段值是由握手请求中的 SecWebSocket-Key 的字段值生成的。

成功握手确立 WebSocket 连接，采用 WebSocket 独立数据帧：

{% asset_img websocket-message.png 500 WebSocket 通信 %}

来看一下 Chrome 下的报文信息：

{% asset_img websocket-handshake.png 650 WebSocket 握手 %}

Javascript 可以调用“WebSocket API”实现 WebSocket 协议下全双工通信，**[点击看效果](http://jsbin.com/xadidosoxe/edit?js,console)**：

1.  WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例

```js
var ws = new WebSocket('ws://example.com')
```

2.  `readyState`属性返回实例对象的当前状态，共四种。

```js
// 1. CONNECTING: 值0，正在连接
// 2. OPEN：值1，连接成功，可以通信了
// 3. CLOSING：值2，连接正在关闭
// 4. CLOSED：值3，连接已关闭
switch (ws.readyState) {
}
```

3.  实例对象的`onopen`属性，用于指定连接成功后的回调函数

```js
ws.onopen = function() {
  ws.send('Hello Server!')
}

// 使用addEventListern，指定多个回调
ws.addEventListener('open', function(event) {
  ws.send('Hello Server!')
})
```

4.  实例对象的`onclose`属性，用于指定连接关闭后的回调函数

```js
ws.onclose = function(event) {
  var code = event.code
  var reason = event.reason
  var wasClean = event.wasClean
}

ws.addEventListener('close', function(event) {
  var code = event.code
  var reason = event.reason
  var wasClean = event.wasClean
})
```

5.  实例对象的`onmessage`属性，用于指定接收到服务器数据后的回调函数

```js
ws.onmessage = function(event) {
  var data = event.data
}

ws.addEventListener('message', function(event) {
  var data = event.data
})
```

注意，服务端数据可能是文本，也可能是二进制数据（`blob`对象或者`ArrayBuffer`对象）。

```js
ws.onmessage = function(event) {
  var data = event.data
  if (typeof data === 'string') {
  }
  if (data instanceof ArrayBuffer) {
  }
}
```

除了动态判断收到的数据类型，还可以使用`binaryType`属性，显示指定收到的二进制数据类型。

```js
// blob数据
ws.binaryType = 'blob'
ws.onmessage = function(event) {
  console.log(event.data.size)
}

// ArrayBuffer数据
ws.binaryType = 'arraybuffer'
ws.onmessage = function(event) {
  console.log(event.data.byteLength)
}
```

6.  实例对象的`send()`方法用于向服务器发送数据。

```js
//发送文本
ws.send('your message')

//发送Blob对象
var file = document.querySelector('input[type="file"]').files[0]
ws.send(file)

//发送ArrayBuffer对象
// Sending canvas ImageData as ArrayBuffer
var img = canvas_context.getImageData(0, 0, 400, 320)
var binary = new Uint8Array(img.data.length)
for (var i = 0; i < img.data.length; i++) {
  binary[i] = img.data[i]
}
ws.send(binary.buffer)
```

7.  实例对象的`bufferedAmount`属性，表示还有多少字节的二进制数据没有发送出去。

```js
var data = new ArrayBuffer(10000000)
ws.send(data)

if (ws.bufferedAmount === 0) {
  // 发送完毕
} else {
  // 发送还没结束
}
```

8.  实例对象的`onerror`属性，用于指定报错事的回调函数。

```js
ws.onerror = function(event) {
  // handle error event
}

ws.addEventListener('error', function(event) {
  // handle error event
})
```

# Web 的攻击技术

**(未完待续)**

# 参考文献

1.  **[阮一峰 HTTP 协议入门](http://www.ruanyifeng.com/blog/2016/08/http.html)**
2.  **[Google Developer HTTP/2 简介](https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn)**
3.  **[阮一峰 WebSocket 教程](http://www.ruanyifeng.com/blog/2017/05/websocket.html)**
4.  **[MDN WebSocket](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket)**
